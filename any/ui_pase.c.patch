--- a/crypto/ui/ui_pase.c	1969-12-31 18:00:00.000000000 -0600
+++ b/crypto/ui/ui_pase.c	2016-04-15 18:47:52.230460000 -0500
@@ -0,0 +1,189 @@
+/* crypto/ui/ui_pase.c */
+/* ====================================================================
+ * Copyright (c) 2000-2015 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include "e_os.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <malloc.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <as400_types.h>
+#include <as400_protos.h>
+
+#if defined(OPENSSL_SYS_PASE)
+
+/* Macros for handling 16-byte alignment of MI pointers */
+#define QUADWORD_ALIGNED_VAR_DECLARE(type, name) \
+type* name; \
+char name##_buf[sizeof(type) + 15]
+
+#define QUADWORD_ALIGNED_VAR_INIT(type, name) \
+name = (type*) (((intptr_t) name##_buf + 0xf) & ~0xf)
+
+#define QUADWORD_ALIGNED_VAR(type, name) \
+QUADWORD_ALIGNED_VAR_DECLARE(type, name); \
+QUADWORD_ALIGNED_VAR_INIT(type, name)
+
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, Qp0zSetTerminalMode_ptr);
+QUADWORD_ALIGNED_VAR_DECLARE(ILEpointer, Qp0zIsATerminal_ptr);
+
+/*
+ * init_ile loads an ILE service program and extracts an
+ * ILE pointer to a procedure that is exported by that
+ * service program.
+ */
+static int init_ile()
+{
+    /* If we haven't forked or have already re-initialized
+     * we're good still
+     */
+    static pid_t init_pid = -1;
+    
+    if (getpid() == init_pid) {
+        return 1;
+    }
+    
+    unsigned long long actmark = _ILELOADX("QSYS/QP0ZTRMLC", ILELOAD_LIBOBJ);
+    if (actmark == -1) {
+        return 0;
+    }
+    
+    QUADWORD_ALIGNED_VAR_INIT(ILEpointer, Qp0zSetTerminalMode_ptr);
+    if (_ILESYMX(Qp0zSetTerminalMode_ptr, actmark, "Qp0zSetTerminalMode") == -1) {
+        return 0;
+    }
+    
+    QUADWORD_ALIGNED_VAR_INIT(ILEpointer, Qp0zIsATerminal_ptr);
+    if (_ILESYMX(Qp0zIsATerminal_ptr, actmark, "Qp0zIsATerminal") == -1) {
+        return 0;
+    }
+    
+    /* If we initialized fully, save the pid that we
+     * initialized in
+     */
+    init_pid = getpid();
+    return 1;
+}
+
+int Qp0zSetTerminalMode(unsigned char mode, unsigned char type)
+{
+    static return_type = RESULT_INT32;
+    static arg_type_t signature[] =
+    {
+        ARG_UINT8,      /* requires #pragma nowiden in ILE code */
+        ARG_UINT8,      /* requires #pragma nowiden in ILE code */
+        ARG_MEMPTR,
+        ARG_END
+    };
+    
+    typedef struct {
+        ILEarglist_base base;
+        unsigned char mode;
+        unsigned char type;
+        ILEpointer reserved;
+    } arglist_t;
+    
+    QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+    
+    arglist->mode = mode;
+    arglist->type = type;
+    arglist->reserved.s.addr = (address64_t) NULL;
+    
+    int rc = -1;
+    if(init_ile()) {
+        rc = _ILECALL(Qp0zSetTerminalMode_ptr,
+                      &arglist->base,
+                      signature,
+                      return_type);
+     
+        rc = rc ? -1 : arglist->base.result.s_int32.r_int32;
+    }
+    
+    return rc;
+}
+
+int Qp0zIsATerminal(int fd)
+{
+    static return_type = RESULT_INT32;
+    static arg_type_t signature[] =
+    {
+        ARG_INT32,
+        ARG_END
+    };
+    
+    typedef struct {
+        ILEarglist_base base;
+        int32 fd;
+    } arglist_t;
+    
+    QUADWORD_ALIGNED_VAR(arglist_t, arglist);
+    
+    arglist->fd = fd;
+    
+    int rc = -1;
+    if(init_ile()) {
+        rc = _ILECALL(Qp0zIsATerminal_ptr,
+                      &arglist->base,
+                      signature,
+                      return_type);
+        
+        rc = rc ? -1 : arglist->base.result.s_int32.r_int32;
+    }
+    
+    return rc;
+}
+
+#endif                          /* OPENSSL_SYS_PASE */
