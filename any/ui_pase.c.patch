*** a/crypto/ui/ui_pase.c	1969-12-31 18:00:00.000000000 -0600
--- b/crypto/ui/ui_pase.c	2015-12-28 18:10:38.543090960 -0600
***************
*** 0 ****
--- 1,205 ----
+ /* crypto/ui/ui_pase.c */
+ /* ====================================================================
+  * Copyright (c) 2000-2015 The OpenSSL Project.  All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  *
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  *
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in
+  *    the documentation and/or other materials provided with the
+  *    distribution.
+  *
+  * 3. All advertising materials mentioning features or use of this
+  *    software must display the following acknowledgment:
+  *    "This product includes software developed by the OpenSSL Project
+  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+  *
+  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+  *    endorse or promote products derived from this software without
+  *    prior written permission. For written permission, please contact
+  *    openssl-core@openssl.org.
+  *
+  * 5. Products derived from this software may not be called "OpenSSL"
+  *    nor may "OpenSSL" appear in their names without prior written
+  *    permission of the OpenSSL Project.
+  *
+  * 6. Redistributions of any form whatsoever must retain the following
+  *    acknowledgment:
+  *    "This product includes software developed by the OpenSSL Project
+  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+  * OF THE POSSIBILITY OF SUCH DAMAGE.
+  * ====================================================================
+  *
+  * This product includes cryptographic software written by Eric Young
+  * (eay@cryptsoft.com).  This product includes software written by Tim
+  * Hudson (tjh@cryptsoft.com).
+  *
+  */
+ #include "e_os.h"
+ 
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include <errno.h>
+ #include <malloc.h>
+ #include <signal.h>
+ #include <sys/types.h>
+ #include <as400_types.h>
+ #include <as400_protos.h>
+ 
+ #if defined(OPENSSL_SYS_PASE)
+ 
+ /*
+  * ROUND_QUAD finds a 16-byte aligned memory
+  * location at or beyond a specified address
+  * 
+  * xlc does not guarantee 16-byte alignment for
+  * automatic (stack) variables of any type, so we
+  * use ROUND_QUAD on an oversized buffer to ensure
+  * the pointer is 16-byte aligned.
+  */
+ 
+ #define ROUND_QUAD(x) (((size_t)(x) + 0xf) & ~0xf)
+ 
+ /*
+  * QUAD_ALIGNED_VAR declares a 16-byte aligned pointer
+  * by declaring an oversized buffer and using ROUND_QUAD
+  * to align the data inside the buffer
+  */
+ #define QUAD_ALIGNED_VAR(type, name) \
+ type* name; \
+ char name##_buf[sizeof(type) + 15]; \
+ name = (type *) ROUND_QUAD(name##_buf)
+ 
+ ILEpointer* qp0zsetterminalmode_ptr;
+ ILEpointer* qp0zisaterminal_ptr;
+ 
+ /*
+  * ROUND_QUAD finds a 16-byte aligned memory
+  * location at or beyond a specified address
+  */
+ #define ROUND_QUAD(x) (((size_t)(x) + 0xf) & ~0xf)
+ 
+ /*
+  * init_ile loads an ILE service program and extracts an
+  * ILE pointer to a procedure that is exported by that
+  * service program.
+  */
+ static int init_ile()
+ {
+     /* If we haven't forked or have already re-initialized
+      * we're good still
+      */
+     static pid_t init_pid = -1;
+     if (getpid() == init_pid) {
+         return 1;
+     }
+     
+     unsigned long long actmark = _ILELOADX("QSYS/QP0ZTRMLC", ILELOAD_LIBOBJ);
+     if (actmark == -1) {
+         printf("QP0ZTRMLC _ILELOADX errno=%d\n", errno);
+         return 0;
+     }
+     
+     if (_ILESYMX(qp0zsetterminalmode_ptr, actmark, "Qp0zSetTerminalMode") == -1) {
+         printf("Qp0zSetTerminalMode _ILESYMX errno=%d\n", errno);
+         return 0;
+     }
+     
+     if (_ILESYMX(qp0zisaterminal_ptr, actmark, "Qp0zIsATerminal") == -1) {
+         printf("Qp0zIsATerminal _ILESYMX errno=%d\n", errno);
+         return 0;
+     }
+     
+     /* If we initialized fully, save the pid that we
+      * initialized in
+      */
+     init_pid = getpid();
+     return 1;
+ }
+ 
+ int Qp0zSetTerminalMode(unsigned char mode, unsigned char type)
+ {
+     static return_type = RESULT_INT32;
+     static arg_type_t signature[] =
+     {
+         ARG_UINT8,      /* requires #pragma nowiden in ILE code */
+         ARG_UINT8,      /* requires #pragma nowiden in ILE code */
+         ARG_MEMPTR,
+         ARG_END
+     };
+     
+     typedef struct {
+         ILEarglist_base base;
+         unsigned char mode;
+         unsigned char type;
+         ILEpointer reserved;
+     } arglist_t;
+     
+     QUAD_ALIGNED_VAR(arglist_t, arglist);
+     
+     arglist->mode = mode;
+     arglist->type = type;
+     arglist->reserved.s.addr = (address64_t) NULL;
+     
+     int rc = -1;
+     if(init_ile()) {
+         rc = _ILECALL(qp0zsetterminalmode_ptr,
+                       &arglist->base,
+                       signature,
+                       return_type);
+      
+         rc = rc ? -1 : arglist->base.result.s_int32.r_int32;
+     }
+     
+     return rc;
+ }
+ 
+ int Qp0zIsATerminal(int fd)
+ {
+     static return_type = RESULT_INT32;
+     static arg_type_t signature[] =
+     {
+         ARG_INT32,
+         ARG_END
+     };
+     
+     typedef struct {
+         ILEarglist_base base;
+         int32 fd;
+     } arglist_t;
+     
+     QUAD_ALIGNED_VAR(arglist_t, arglist);
+     
+     arglist->fd = fd;
+     
+     int rc = -1;
+     if(init_ile()) {
+         rc = _ILECALL(qp0zisaterminal_ptr,
+                       &arglist->base,
+                       signature,
+                       return_type);
+         
+         rc = rc ? -1 : arglist->base.result.s_int32.r_int32;
+     }
+     
+     return rc;
+ }
+ 
+ #endif                          /* OPENSSL_SYS_PASE */
